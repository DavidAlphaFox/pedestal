= Using Pedestal With Component

link:{component_home}[Component] is a popular and non-intrusive library for organizing
Clojure logic; it makes it easy to define _components_, as maps or Clojure records, and organize them, with intra-component
dependencies,
into a _system map_.

It's not uncommon for Pedestal to be setup to operate as a component with a Component system.

== What You Will Learn
After reading this guide you will be able to:

- Create a Component-based service using Pedestal.
- Make updates to your service without restarting your REPL.
- Test your service using Pedestal's test helpers.

== Guide Assumptions
This guide is for users who are familiar with:

- Clojure
- Pedestal
- Clojure's CLI tooling
- Component

If you are new to Pedestal, you may want to go back to the
xref:hello-world.adoc[] guide.

If you're new to Component, you
should definitely link:{component_home}[check it out] first.

== Getting Help if You're Stuck

include::partial$getting-help.adoc[]

== Where We Are Going

In this guide, we're going to step through creating a Pedestal service
using Component. We'll start off by creating a Pedestal component and
wire it into a Component system map. We'll then proceed to testing our
service.

== Before We Begin

We are going to have a component that manages the Pedestal connector.
A second component will be a "big bag of components" that will be provided
to every interceptor or handler function in a new :components key of the
xref:reference:request-map.adoc[].  We'll also have a component with some mutable
state to interact with from our handler.

We can represent the system map as a diagram, showing components and their dependencies:

[graphviz]
----
digraph G {
 ":pedestal" -> ":components";
":components" -> ":greeter";
}
----

This is a very flat map; it shows that the :pedestal component
depends on the :components component, which itself depends on
the :greeter component.

Real systems built with the Component library will often have dozens of
components and even more dependencies, but this small start still demonstrates
a valid pattern.

Now that we have a better idea of the system layout, let's start building it.

== Project and Dependencies

The first step is to create a project directory to contain the project sources,
then create a `deps.edn` file, to capture the dependencies of our application.

[source,clojure]
.deps.edn
----
include::example$component/deps.edn[]
----
<1> We'll need this library later.
<2> This will be used inside our tests.
<3> This makes it possible to reload changed namespaces quickly and easily, using the {clj-reload} library.
<4> This will be used to enable xref:reference:dev-mode.adoc[], which makes developing at the REPL easier.

== Component System Map

We're going to build the application top-down, starting with the system map.
footnote:[This isn't actually fair. The application was originally built bottom up, a little bit at a time.
But that approach is confusing to explain.]

The `app.system` namespace it the highest structure in the application; it defines all the
components in the system, and how they depend on each other.

Create a `src` directory, and then an `app` directory beneath that.  That's where more of our project's code will live.

[source, clojure]
.src/app/system.clj
----
include::example$component/src/app/system.clj[tag=ns]
----
<2> These two namespaces haven't been written yet.

The `system-map` function defines a Component SystemMap in terms of key and value pairs.
Each key is a keyword, and each value is a map or Clojure record.  The `using` function
identifies on which other components each component depends.

One namespace down, at least two to go.  Let's work on the Pedestal component next.

== Pedestal Component

The :pedestal component will be responsible for configuring the Pedestal connector, and starting it.

[source, clojure]
.src/app/pedestal.clj
----
include::example$component/src/app/pedestal.clj[tags=ns]
----
<1> We need to require `com.stuartsierra.component`  namespace to make the
`start` and `stop` Lifecycle methods available.
<2> This, _once created_, will define routes and handlers for the application.

=== Component Injection

Earlier we said that we want to make certain components of the system map available to interceptors
and handlers; we'll define a custom interceptor for that purpose:

[source, clojure]
.src/app/pedestal.clj
----
include::example$component/src/app/pedestal.clj[tags=inject]
----

This is actually a function that _returns_ an interceptor.
When the interceptor is eventually executed in the :enter phase,
it will modify the context map passed to it, injecting the components map into the request map for later
access.  Where does the map of components come from?  We're almost there.

=== Lifecycle Protocol

Let's start implementing the :pedestal component, as a Clojure record type.

A Clojure record is a Clojure map that has certain built-in fields; in addition,
a record can extend Clojure protocols. The result is a new class. The fields
of the record are typically used to store dependencies and any local state, mutable or otherwise.

[source,clojure]
----
include::example$component/src/app/pedestal.clj[tags=component]
)
----
<1> Create a Pedestal record. This record will contain a `components` field, whose value
will be supplied from another component, and a `connector` field, managed by the Pedestal component.
<2> Include the _component/Lifecycle_ protocol since we'll be
implementing its methods next.

We'll first implement the `start` method of the `Lifecycle` protocol. It will contain our
component initialization code.

[source,clojure]
----
include::example$component/src/app/pedestal.clj[tags=start]
----
<1> We're adding the Pedestal connector to the component.
<2> Create and add the ::inject-components interceptor to the very start of the interceptor list.
<3> If the process was started in xref:reference:dev-mode.adoc[], add additional development-only interceptors.
<4> We haven't defined the `app.route/routes` value yet.
<5> Convert from a connector map to an (unstarted) connector.

This `start` method goes _inside_ `defrecord`, after the `components/Lifecycle` line.

[TIP]
.Every start deserves a stop
====
You might think that there's no need to add `stop` since your service will run until it's process
is killed.

That _may_ be true in production, but in development and testing, this is far from the case.

You should always _undo_, in `stop`, the changes made in `start`.
In this example, we need to make sure that the Pedestal connector is stopped,
or we could end up with a zombie thread keeping port 8890 locked.
Generally, our tests create a new system map, start it, run tests, then stop it ...
but Component can also handle cases where the system map is created _once_ and repeatedly started and stopped.
====

Now let's implement the `stop` method. It will contain our component
teardown code.

[source,clojure]
----
include::example$component/src/app/pedestal.clj[tags=stop]
----

Most importantly here, we `stop!` the Pedestal connector; this ensure that port 8890 is no longer bound.
That's pretty important later, when we want to work with REPL-oriented development.

[CAUTION]
.Don't `dissoc` in `stop`
====
If we used clj:dissoc[] here (instead of `assoc nil`), we would be removing a record key from a record; Clojure would quietly
convert from a Pedestal record to a standard Clojure map. This isn't a big deal, unless we try to start and stop
the same system map repeatedly; the second start would not work because the Clojure map has no `start` method.
====

Now that we've got our component, we need a way to
create and initialize an instance of it. Let's tackle that next:
----
include::example$component/src/app/pedestal.clj[tags=constructor]
----
Our component constructor is just a wrapper around the map-specific
record constructor created by `defrecord`. The `defrecord` macro
creates a number of constructors and any of them could be used here.

[TIP]
It's common to create a simple wrapper function, as shown here; quite often,
components grow to need additional setup and initialization which can occur in this kind of
creation function.

A service that doesn't define any routes is not particularly useful so our next step is to provide at least one route.

== Defining Routes

The :pedestal component expects the symbol `app.routes/routes` to be the routes for the application.
Let's create that file now.

We're going to define an endpoint for `GET /greet`; it will return a dynamic string: "Greeting #1", then "Greeting #2" and so forth on later requests.

Let's get started:

Create a `src/app/routes.clj` file. This file will contain our routes and
handlers. Well, just the one, because this is a toy example.

[source, clojure]
.src/app/routes.clj
----
include::example$component/src/app/routes.clj[tags=response]
----
<1> Remember, we haven't defined this component yet.
<2> The :components map provided by the ::inject-components interceptor.


That's the handler, lets define the route that maps to the handler:

----
include::example$component/src/app/routes.clj[tags=routes]
----

[TIP]
In this simple example, we use `def`, as the routes are entirely static.
In many applications, some parts of the routes would be more dynamic, and `routes`
would be a function with arguments.

== Greeting Component

The best handlers in a Pedestal application are very simple, dealing with the Pedestal logic and structure
of the request and response maps, with all the real application-specific logic in a component or function.

In our case, we have a Greeter component that builds the response body.  Let's create that now.

[source, clojure]
.src/app/components/greeter.clj
----
include::example$component/src/app/components/greeter.clj[tags=gen-preamble]
----
<1> Ignore this for now.

That's the component and its lifecycle, including a place to store some internal state ... how many times
the greeting was retrieved.  Next we can focus on the actual logic:

[source,clojure]
----
include::example$component/src/app/components/greeter.clj[tags=gen1]
----
<1> Another Clojure naming convention: _impure_ functions in Clojure are suffixed with a `!`.
footnote:[Impure functions can vary their result even when provided with the same input. Pure functions always return
 the same value for the same inputs.  Functions may be impure because they
have hidden mutable state, or because they perform some kind of I/O - even something as minor are reading the system clock.]

We're just about ready to fire this puppy up and kick the tires!
footnote:[Sorry for the mixed metaphor.]

== User Namespace

Technically, we have enough now to run our service, but for ease of use, we're going to add a `user` namespace.
At startup, Clojure always loads the `user` namespace if it is available.

Create a `test` directory in the project root, and a `user.clj` within it.

[source,clojure]
----
include::example$component/test/user.clj[]
----
<1> This is required to make use of {clj-reload}, which is key to REPL oriented development.
<2> The system map will be stored in this global atom.

Ok, *now* let's fire up these tires and kick that puppy!

== Running It

We'll use `clj` tool to run our
example. This should be familiar to you if you read through the
xref:hello-world.adoc[].

From the project's root directory, fire up a REPL, and start the system.
----
$ clj -A:test:dev-mode <1>
Clojure 1.12.0
user=> (start!) <2>
Routing table:
┏━━━━━━━━┳━━━━━━━━┳━━━━━━━━┓ <3>
┃ Method ┃  Path  ┃  Name  ┃
┣━━━━━━━━╋━━━━━━━━╋━━━━━━━━┫
┃   :get ┃ /greet ┃ :greet ┃
┗━━━━━━━━┻━━━━━━━━┻━━━━━━━━┛
#<SystemMap> <4>
user=>
----

<1> The :test alias adds the `test` directory and some other dependencies to the classpath. The :dev-mode enables development mode.
<2> Here's that handy command from `user.clj`.
<3> In development mode, the routing table is printed to the console at startup (and whenever a change is detected).
footnote:[Also, in the console it prints correctly: the verticle bar align and connect. It looks a bit jarring here.]
<4> This is the printed representation of the Component system map.

You can now interact with the started service. Start a second terminal window and use `curl` to access the `/greet` route:

----
$ curl http://localhost:8890/greet
Greeting #1
$ curl http://localhost:8890/greet
Greeting #2
$
----

That's what we want to see!

You'll also see messages in the console of the server REPL:

----
[] INFO io.pedestal.service.interceptors - {:msg "GET /greet", :line 40}
[] INFO io.pedestal.service.interceptors - {:msg "GET /greet", :line 40}
----

These messages are quite minimal because we haven't configured logging in any way.

Two important areas remain: REPL oriented development, and testing.  Let's get a feel for how awesome the Clojure REPL is.

== REPL oriented development

Let's see if we can get a prettier response to the client.

Let's make changes to the Greeter component:

[source,clojure]
.src/app/components/greeter.clj
----
include::example$component/src/app/components/greeter.clj[tags=gen2]
----
<1> `ordinal` returns "1st", "2nd", "3rd", "4th", etc.

Just changing the source doesn't affect the running program, but we can use {clj-reload} to load the changes.

[source]
----
user=> (clj-reload.core/reload)
Unloading user
Unloading app.system
Unloading app.pedestal
Unloading app.routes
Unloading app.components.greeter
Loading app.components.greeter
Loading app.routes
Loading app.pedestal
Loading app.system
Loading user
Reloaded 5 namespaces in 54 ms
{:unloaded [user app.system app.pedestal app.routes app.components.greeter], :loaded [app.components.greeter app.routes app.pedestal app.system user]}
user=>
----

clj-reload has identified which files have changed, and has unloaded and reloaded all files affected by the changes.  The code continues to run; it isn't even necessary to `stop!` and `start!` the service.

[source]
----
$ curl http://localhost:8890/greet
Greetings for the 3rd time
----

We can also modify our routes, giving our API a different URL:

[source,clojure]
.src/app/routes.clj
----
include::example$component/src/app/routes.clj[tags=routes2]
----

Again, reload namespaces, then:

[source]
----
$ curl http://localhost:8890/greet
Not Found
----

That's actually successful ... we've changed our routes to respond to `/api/greet`, so the URL `/greet` is met with a 404 Not Found response.


If you look in your REPL window, you'll see that your change has been adopted, and the new routing table printed:

[source]
----
[] INFO io.pedestal.service.interceptors - {:msg "GET /greet", :line 40}
Routing table:
┏━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━┓
┃ Method ┃    Path    ┃  Name  ┃
┣━━━━━━━━╋━━━━━━━━━━━━╋━━━━━━━━┫
┃   :get ┃ /api/greet ┃ :greet ┃
┗━━━━━━━━┻━━━━━━━━━━━━┻━━━━━━━━┛
----

Using the correct URL gets the expected result:

[source]
----
$ curl http://localhost:8890/api/greet
Greetings for the 4th time
----

At this point, we've seen that we can iterate quickly when in development mode.
You should be aware that when running a system map when development mode is _disabled_,
you will see that Pedestal gets "locked in" to the routes and many function definitions,
even after code is changed and reloaded ... you'll often have to `(stop!)` and `(start!)` to see the effects of reloading namespaces.

Fortunately, starting and stopping the system map is very quick, which is important when it comes to the next subject ... testing.

// TODO: continue from here

== Testing

Let's move on to testing our new service. Recall that our service contains one
route, `GET /greet`. We'd like to verify that it returns the proper
greeting. Before we can jump in and do that, though, we need to create
some helpers. Some are just useful in general, while others are
specific to our component implementation. Don't worry, you won't have
to write too much code. Let's do it!

First create a `system_test.clj` file in the `src` directory.

[source, clojure]
.test/system_test.clj

----
include::example$component/test/app/system_test.clj[tags=ns]
----
The `system-test` namespace requires all the dependencies
necessary for testing.

Now let's get to those helpers.

The `url-for` helper allows us to refer to routes by
_route-name_. This is very useful, and is almost always adapted into new projects.
----
include::example$component/test/app/system_test.clj[tags=url-for]
----
We need to expand the routes before invoking Pedestal's
api:url-for-routes[ns=io.pedestal.http.route] function.

The end result is that `url-for` is a function

The `service-fn` helper extracts the Pedestal ::http/service-fn from
the started system. This helper allows us to keep focus on our
tests rather than test initialization.
----
include::example$component/test/app/system_test.clj[tags=service-fn]
----


The `with-system` macro allows us to start/stop systems between test
executions. We'll model its design on macros like `with-open` and
`with-redefs` so that its shape and usage is familiar.
----
include::example$component/test/app/system_test.clj[tags=with-system]
----

Now that we've got our helpers implemented, let's move on to our
test. Create a test named `greeting-test`.
----
include::example$component/test/app/system_test.clj[tags=test]
----
<1> `sut` (for _system under test_) will be bound to the started
system by `with-system`. Notice how :test is passed as the system
environment key; this ensures that the server does not start, and no HTTP port is bound.
<2> Use the `service-fn` helper to extract the Pedestal service
function from the started system.
<3> Use Pedestal's `response-for` test helper to make a test request
to the :greet route. Use the `url-for` helper to refer to the route
by name.
<4> We should get back a '200' status.
<5> We should get back a response body of 'Hello, world!'

Now let's restart run the tests from the command line:
----
> clj -X:test

Running tests in #{"test"}

Testing system-test
[main] INFO io.pedestal.http - {:msg "GET /greet", :line 90}

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
>
----

That's it! You now know the fundamentals necessary for implementing
and testing your Component-based Pedestal services.

== The Whole Shebang
For reference, here are the complete contents of all the files.


[source,clojure,subs="-callouts"]
.src/pedestal.clj
----
include::example$component/src/app/pedestal.clj[tags=ns]

include::example$component/src/app/pedestal.clj[tags=test?]

include::example$component/src/app/pedestal.clj[tags=component-init]
include::example$component/src/app/pedestal.clj[tags=component-start]
include::example$component/src/app/pedestal.clj[tags=component-stop]

include::example$component/src/app/pedestal.clj[tags=constructor]
----



[source,clojure,subs="-callouts"]
.src/routes.clj
----
include::example$component/src/app/routes.clj[tags=response]

include::example$component/src/app/routes.clj[tags=routes]
----



[source,clojure,subs="-callouts"]
.src/system.clj
----
include::example$component/src/app/system.clj[tags=ns]

include::example$component/src/app/system.clj[tags=app]

include::example$component/src/app/system.clj[tags=init]
----



[source,clojure,subs="-callouts"]
.test/system_test.clj
----
include::example$component/test/app/system_test.clj[tags=ns]

include::example$component/test/app/system_test.clj[tags=url-for]

include::example$component/test/app/system_test.clj[tags=service-fn]

include::example$component/test/app/system_test.clj[tags=with-system]

include::example$component/test/app/system_test.clj[tags=test]
----


[source,clojure,subs="-callouts"]
.deps.edn
----
include::example$component/deps.edn[]
----

== The Path So Far
At the beginning of this guide, we set out to create a Pedestal
component, demonstrate its usage as well as how to test it without
starting the http server. In the process, we also introduced a few general purpose
test helpers.

Keep in mind that Pedestal services are highly configurable. It's
important to separate that configuration from the core component
implementation. By limiting our component's responsibilities to http
server and Pedestal provider life cycle support, we can use it in a
wide variety of Pedestal implementations.

