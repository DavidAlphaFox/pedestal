= Unit testing
:default_api_ns: io.pedestal.connector.test

It is a good practice to separate core business logic from handler,
and more generally, interceptor code. This separation of concerns has
many benefits, including facilitating testing at the interceptor, interceptor
chain and end-to-end response generation levels.

[TIP]
====
This document described unit testing when using
api:*[ns=io.pedestal.connector], the
xref:0.7@pedestal:guides:unit-testing.adoc[0.7 version of this documentation] discusses the
equivalent work when using api:*[ns=io.pedestal.http].
====

== Testing interceptors in isolation

Interceptors can be tested in isolation by either directly invoking the
:enter, :leave or :error functions with a mock context map in your test
or by using the interceptor chain
api:execute[ns=io.pedestal.interceptor.chain]
function. Both approaches are demonstrated below.

Given the following interceptor:

[source,clojure]
----
(def widget-finder
     (interceptor/interceptor
      {:enter (fn [ctx]
                (assoc ctx :widget {:id 1 :title "foobar"} ))}))
----

We can test it either directly:

[source,clojure]
----
(let [test-fn (:enter widget-finder)]
  (is (= {:id 1 :title "foobar"} (:widget (test-fn {})))))
----

Or using the interceptor chain api:execute[ns=io.pedestal.interceptor.chain]
function:

[source,clojure]
----
(is (= {:id 1 :title "foobar"} (:widget (chain/execute {} [widget-finder]))))
----

[CAUTION]
====
The value, `widget-finder` in this example, must be an interceptor, not a map that can
be converted into an interceptor.  The api:interceptor[ns=io.pedestal.interceptor] macro
ensures this.
====

We can extend this approach to test coordination across multiple interceptors as follows:

[source,clojure]
----
(def widget-renderer
  (interceptor/interceptor
   {:leave (fn [ctx]
             (if-let [widget (:widget ctx)]
               (assoc ctx :response {:status 200
                                     :body   (format "Widget ID %d, Title '%s'"
                                                     (:id widget)
                                                     (:title widget))})
               (assoc ctx :response {:status 404 :body "Not Found"})))}))

(is (= "Widget ID 1, Title 'foobar'"
       (get-in (chain/execute {} [widget-renderer widget-finder])
               [:response :body])))
----

== Testing your service with `response-for`

The value in exercising the end-to-end operation of your service endpoints is
that it provides quick feedback that you've wired things up correctly. Pedestal
provides the test helper function
api:response-for[], which makes it possible to fully test a route
without starting up an HTTP service.

This style of testing ensures that routing is correct, and it fully exercises routing, interceptors,
and any business logic.

The `response-for` function works with initialized, but *not started*,
xref:reference:connector.adoc[].

At a minimum, it is used to build a xref:reference:request-map.adoc[] and returns a
xref:reference:response-map.adoc[].

[source,clojure]
----
(let [response (response-for connector :get "/api/hello")]
   ...)
----

=== response-for arguments

* The Pedestal connector
* The _verb_ (aka, HTTP reqeust method) as a keyword (i.e., :get, :post, :delete, etc...).
* The _url_ is a complete URL, or relative to the root of the service

Following the three required arguments are further optional arguments, as key/value pairs.

==== :headers

A map of keys and values for the headers to send in the request.

Keys and values are normally strings, but you may also use keywords or symbols for keys and values;
they will be converted to strings. footnote:[Qualified keywords or symbols will lose the namespace part.]
Header strings are always converted to lower case.


==== :body

Defines the :body of the request.  The value provided may be a String, an InputStream,
or a File.  This will be converted to an InputStream in the request :body.

[TIP]
====
Advanced users can extend the api:RequestBodyCoercion[] protocol onto new types to support
additional :body types.
====

==== :as

The response body will normally be nil or an InputStream; the :as parameter
enables a conversion to something easier for tests.  The default is :string (treat the response as a UTF-8 encoded byte stream), but the values :byte-buffer and :stream are also allowed.

=== response map

To assist with testing, the headers in the response map are modified; normally they consist
of string values and string keys; `response-for` converts the keys to lower case keywords.  For example,
the "Content-Type" header will be converted to :content-type.  The values are unchanged, but keywords are
easier to oeprate on in test assertions.

=== Testing GET requests

The following example illustrates a simple execution of `response-for`
within a test:

[source,clojure]
----
(is (= "Hello!" (:body (response-for connector :get "/hello"))))
----

A GET request has no body to specify, so the :body argument is simply omitted.

A test could also make assertions about the response headers:

[source,clojure]
----
(let [response (response-for connector :get "/hello")]
  (is (= "text/plain"
      (get-in response [:headers :content-type]))))
----

Using the extremely useful {matcher-combinators} library, we can combine these tests into one (and verify
the response status for good measure):

[source,clojure]
----
(is (match? {:status 200
             :headers {:content-type "text/plain"}
             :body "Hello!"}
            (response-for connector :get "/hello")))
----


=== Testing POST

POST'ing to a service endpoint can be tested by using the :post verb
and specifying a request :body. The route under test typically
includes the
api:body-params[ns=io.pedestal.http.body-params]
interceptor to support request payload parsing - which is driven
by the `Content-Type` header, which identifies how to parse the body, so the header
must be specified:

[source,clojure]
----
(is (match? {:status 200}
            (response-for connector :post "/foo"
                          :headers {:content-type "application/json"}
                          :body "{\"foo\":\"bar\"}")))
----

If testing an HTTP form submission, it is similar except for how the content is encoded and described.

[source,clojure]
----
(is (match? {:status 200}
            (response-for connector :post "/login"
                          :headers {:content-type "application/x-www-form-urlencoded"}
                          :body "username=test@test.com&password=my-pwd")))
----

=== Testing Async interactions

Nothing special needs to be done when testing routes which include
async interactions. The `response-for` helper forces asynchronous
request processing to complete before returning a value.

== Testing WebSockets and SSE

Truly asynchronous operations, such as xref:reference:websockets.adoc[] and xref:reference:server-sent-events.adoc[]
can't be tested using `response-for`; it is necessary to fully start the connector and have a client send proper requests
to the service - this is integration testing, beyond the scope of this document.
