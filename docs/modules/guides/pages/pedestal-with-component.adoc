= Using Pedestal With Component

link:{component_home}[Component] is a popular and non-intrusive library for organizing
Clojure logic; it makes it easy to define _components_, as maps or Clojure records, and organize them, with intra-component
dependencies,
into a _system map_.

It's not uncommon for Pedestal to be setup to operate as a component with a Component system.

== What You Will Learn
After reading this guide you will be able to:

- Create a Component-based service using Pedestal.
- Test your service using Pedestal's test helpers.

== Guide Assumptions
This guide is for users who are familiar with:

- Clojure
- Pedestal
- Clojure's CLI tooling
- Component

If you are new to Pedestal, you may want to go back to the
xref:hello-world.adoc[] guide.

If you're new to Component, you
should definitely link:{component_home}[check it out] first.

== Getting Help if You're Stuck

include::partial$getting-help.adoc[]

== Where We Are Going

In this guide, we're going to step through creating a Pedestal service
using Component. We'll start off by creating a Pedestal component and
wire it into a Component system map. We'll then proceed to testing our
service.

== Before We Begin

We are going to have a component that manages the Pedestal connector.
A second component will be a "big bag of components" that will be provided
to every interceptor or handler function in a new :components key of the
xref:reference:request-map.adoc[].  We'll also have a component with some mutable
state to interact with from our handler.

We will have a very flat system map:

[graphviz]
----
digraph G {
 ":pedestal" -> ":components";
":components" -> ":greeter";
}
----

Now that we have a better idea of the layout, let's start building it.

== Project and Dependencies

The first step is to create a project directory to contain the project sources,
then create a `deps.edn` file, to capture the dependencies of our application.

[source,clojure]
.deps.edn
----
include::example$component/deps.edn[]
----
<1> We'll need this library later.
<2> This will be used inside our tests.
<3> This makes it possible to reload changed namespaces quickly and easily, using the {clj-reload} library.
<4> This will be used to enable xref:reference:dev-mode.adoc[], which makes developing at the REPL easier.

== Component System Map

We're going to build the application top-down, starting with the system map.
footnote:[This isn't actually fair. The application was originally built bottom up, a little bit at a time.
But that approach is confusing to explain.]

The `app.system` namespace it the highest structure in the application; it defines all the
components in the system, and how they depend on each other.

Create a `src` directory, and then an `app` directory beneath that.  That's where more of our project's code will live.

[source, clojure]
.src/app/system.clj
----
include::example$component/src/app/system.clj[tag=ns]
----
<2> These two namespaces haven't been written yet.

The `system-map` function defines a Component SystemMap in terms of key and value pairs.
Each key is a keyword, and each value is a map or Clojure record.  The `using` function
identifies on which other components each component depends.

Real Component applications often have dozens of components and myraid interconnections.

One namespace down, at least two to go.  Let's work on the Pedestal component next.

== Pedestal Component

The Pedestal component will be responsible for configuring the Pedestal connector, and starting it.

[source, clojure]
.src/app/pedestal.clj
----
include::example$component/src/app/pedestal.clj[tags=ns]
----
<1> We need to require `com.stuartsierra.component`  namespace to make the
`start` and `stop` Lifecycle methods available.
<2> This, _once created_, will define routes and handlers for the application.

=== Component Injection

Earlier we said that we want to make certain components of the system map available to interceptors
and handlers; we'll define a custom interceptor for that purpose:

[source, clojure]
.src/app/pedestal.clj
----
include::example$component/src/app/pedestal.clj[tags=inject]
----

This is actually a function that returns an interceptor. When the interceptor is eventually
executed in the :enter phase,
it will modify the context map passed to it, injecting the components map into the request map for later
access.  Where does the map of components come from?  Where almost there.

=== Lifecycle Protocol

Let's start implementing the component:

[source,clojure]
----
include::example$component/src/app/pedestal.clj[tags=component]
)
----
<1> Create a Pedestal record. This record will contain a `components` field, whose value
will be supplied from another component, and a `connector` field, managed by the Pedestal component.
<2> Include the _component/Lifecycle_ protocol since we'll be
implementing its methods next.

We'll first implement the `start` method of the `Lifecycle` protocol. It will contain our
component initialization code.

[source,clojure]
----
include::example$component/src/app/pedestal.clj[tags=start]
----
<1> We're adding the Pedestal connector to the component.
<2> Create and add the ::inject-components interceptor to the very start of the interceptor list.
<3> If the process was started in xref:reference:dev-mode.adoc[], add additional development-only interceptors.
<4> We haven't defined the `app.route/routes` value yet.
<5> Convert from a connector map to an (unstarted) connector.

This `start` method goes _inside_ `defrecord`, after the `components/Lifecycle` line.

[TIP]
.Every start deserves a stop
====
You might think that there's no need to add `stop` since your service will run until it's process
is killed.

That _may_ be true in production, but in development and testing, this is far from the case.

You should always _undo_, in `stop`, what you did in `start`. In this example, we need to make
sure that the Pedestal connector is stopped, or we could end up with a zombie thread
keeping port 8890 locked.  Generally, our tests create a new system map, start it, run tests, then stop it ...
but Component can also handle cases where the system map is created _once_ and repeatedly started and stopped.
====

Now let's implement the `stop` method. It will contain our component
teardown code.

[source,clojure]
----
include::example$component/src/app/pedestal.clj[tags=stop]
----

Most importantly here, we `stop!` the Pedestal connector; this ensure that port 8890 is no longer bound.
That's pretty important later, when we want to work with REPL-oriented development.

[CAUTION]
.Don't `dissoc` in `stop`
====
If we used `dissoc` here (instead of `assoc nil`), we would be removing a record key from a record; Clojure would quietly
convert from a Pedestal record to a standard Clojure map. This isn't a big deal, unless we try to start and stop
the same system map repeatedly; the second start would not work because the Clojure map has no `start` method.
====

Now that we've got our component, we need a way to
create and initialize an instance of it. Let's tackle that next:
----
include::example$component/src/app/pedestal.clj[tags=constructor]
----
Our component constructor is just a wrapper around the map-specific
record constructor created by `defrecord`. The `defrecord` macro
creates a number of constructors and any of them could be used here.

[TIP]
It's common to create a simple wrapper function, as shown here; quite often,
components grow to need additional setup and initialization which can occur in this kind of
creation function.

Next in our top-down tour is


== Defining Routes

The Pedestal component expects the symbol `app.routes/routes` to be the routes for the application.
Let's create that file now.

We're going to define an endpoint for `GET /greet`; it will return a dynamic string: "Greeting #1", then "Greeting #2" and so forth on later requests.

Let's get started:

Create a `src/app/routes.clj` file. This file will contain our routes and
handlers. Well, just the one, because this is a toy example.

[source, clojure]
.src/app/routes.clj
----
include::example$component/src/app/routes.clj[tags=response]
----
<1> Remember, we haven't defined this component yet.
<2> The :components map provided by the ::inject-components interceptor.


That's the handler, lets define the routes for the application.

----
include::example$component/src/app/routes.clj[tags=routes]
----

[TIP]
In this simple example, we use `def`, as the routes are entirely static.
In many applications, some parts of the routes would be more dynamic, and `routes`
would be a function with arguments.

== Greeting Component

The best handlers in a Pedestal application are very simple, dealing with the Pedestal logic and structure
of the request and response maps, with all the real application-specific logic in a component or function.

In our case, we have a Greeter component that builds the reponse body.  Let's create that now.

[source, clojure]
.src/app/components/greeter.clj
----
include::example$component/src/app/components/greeter.clj[tags=gen-preamble]
----
<1> Ignore this for now.

That's the component and its lifecycle, now we can focus on the actual logic, which builds on it:

[source,clojure]
----
include::example$component/src/app/components/greeter.clj[tags=gen1]
----
<1> Another Clojure naming convention: _impure_ functions in Clojure are suffixed with a `!`.
footnote:[Impure functions can vary their result even when provided with the same input. Pure functions always return
 the same value for the same inputs.  Functions may be impure because they
have hidden mutable state, or because they perform some kind of I/O - even something as minor are reading the system clock.]

We're just about ready to fire this puppy up and kick the tires!
footnote:[Sorry for the mixed metaphor.]

== User Namespace

Technically, we have enough now to run our service, but for ease of use, we're going to add a `user` namespace.
At startup, Clojure always loads the `user` namespace if it is available.

Create a `test` directory in the project root, and a `user.clj` within it.

[source,clojure]
----
include::example$component/test/user.clj[]
----
<1> This is required to make use of {clj-reload}, which is key to REPL oriented development.
<2> The system map will be stored in this global atom.

Ok, *now* let's fire up these tires and kick that puppy!

== Running It

We'll use `clj` tool to run our
example. This should be familiar to you if you read through the
xref:hello-world.adoc[].

From the project's root directory, fire up a REPL, and start the system.
----
$ clj -A:test:dev-mode <1>
Clojure 1.12.0
user=> (start!) <2>
Routing table:
┏━━━━━━━━┳━━━━━━━━┳━━━━━━━━┓ <3>
┃ Method ┃  Path  ┃  Name  ┃
┣━━━━━━━━╋━━━━━━━━╋━━━━━━━━┫
┃   :get ┃ /greet ┃ :greet ┃
┗━━━━━━━━┻━━━━━━━━┻━━━━━━━━┛
#<SystemMap> <4>
user=>
----

<1> The :test alias adds the `test` directory and some other dependencies to the classpath. The :dev-mode enables development mode.
<2> Here's that handy command from `user.clj`.
<3> In development mode, the routing table is printed to the console at startup (and whenever a change is detected).
<4> This is the printed representation of the Component system map.

You can now interact with the started service. Start a second terminal window and use `curl` to access the `/greet` route:

----
$ curl http://localhost:8890/greet
Greeting #1
$ curl http://localhost:8890/greet
Greeting #2
$
----

That's what we want to see!

You'll also see messages in the console of the server REPL:

----
[] INFO io.pedestal.service.interceptors - {:msg "GET /greet", :line 40}
[] INFO io.pedestal.service.interceptors - {:msg "GET /greet", :line 40}
----

These messages are quite minimal because we haven't configured logging in any way.


== REPL oriented development




== Testing
Let's move on to testing our new service. Recall that our service contains one
route, `GET /greet`. We'd like to verify that it returns the proper
greeting. Before we can jump in and do that, though, we need to create
some helpers. Some are just useful in general, while others are
specific to our component implementation. Don't worry, you won't have
to write too much code. Let's do it!

First create a `system_test.clj` file in the `src` directory.

[source, clojure]
.test/system_test.clj

----
include::example$component/test/app/system_test.clj[tags=ns]
----
The `system-test` namespace requires all the dependencies
necessary for testing.

Now let's get to those helpers.

The `url-for` helper allows us to refer to routes by
_route-name_. This is very useful, and is almost always adapted into new projects.
----
include::example$component/test/app/system_test.clj[tags=url-for]
----
We need to expand the routes before invoking Pedestal's
api:url-for-routes[ns=io.pedestal.http.route] function.

The end result is that `url-for` is a function

The `service-fn` helper extracts the Pedestal ::http/service-fn from
the started system. This helper allows us to keep focus on our
tests rather than test initialization.
----
include::example$component/test/app/system_test.clj[tags=service-fn]
----


The `with-system` macro allows us to start/stop systems between test
executions. We'll model its design on macros like `with-open` and
`with-redefs` so that its shape and usage is familiar.
----
include::example$component/test/app/system_test.clj[tags=with-system]
----

Now that we've got our helpers implemented, let's move on to our
test. Create a test named `greeting-test`.
----
include::example$component/test/app/system_test.clj[tags=test]
----
<1> `sut` (for _system under test_) will be bound to the started
system by `with-system`. Notice how :test is passed as the system
environment key; this ensures that the server does not start, and no HTTP port is bound.
<2> Use the `service-fn` helper to extract the Pedestal service
function from the started system.
<3> Use Pedestal's `response-for` test helper to make a test request
to the :greet route. Use the `url-for` helper to refer to the route
by name.
<4> We should get back a '200' status.
<5> We should get back a response body of 'Hello, world!'

Now let's restart run the tests from the command line:
----
> clj -X:test

Running tests in #{"test"}

Testing system-test
[main] INFO io.pedestal.http - {:msg "GET /greet", :line 90}

Ran 1 tests containing 2 assertions.
0 failures, 0 errors.
>
----

That's it! You now know the fundamentals necessary for implementing
and testing your Component-based Pedestal services.

== The Whole Shebang
For reference, here are the complete contents of all the files.


[source,clojure,subs="-callouts"]
.src/pedestal.clj
----
include::example$component/src/app/pedestal.clj[tags=ns]

include::example$component/src/app/pedestal.clj[tags=test?]

include::example$component/src/app/pedestal.clj[tags=component-init]
include::example$component/src/app/pedestal.clj[tags=component-start]
include::example$component/src/app/pedestal.clj[tags=component-stop]

include::example$component/src/app/pedestal.clj[tags=constructor]
----



[source,clojure,subs="-callouts"]
.src/routes.clj
----
include::example$component/src/app/routes.clj[tags=response]

include::example$component/src/app/routes.clj[tags=routes]
----



[source,clojure,subs="-callouts"]
.src/system.clj
----
include::example$component/src/app/system.clj[tags=ns]

include::example$component/src/app/system.clj[tags=app]

include::example$component/src/app/system.clj[tags=init]
----



[source,clojure,subs="-callouts"]
.test/system_test.clj
----
include::example$component/test/app/system_test.clj[tags=ns]

include::example$component/test/app/system_test.clj[tags=url-for]

include::example$component/test/app/system_test.clj[tags=service-fn]

include::example$component/test/app/system_test.clj[tags=with-system]

include::example$component/test/app/system_test.clj[tags=test]
----


[source,clojure,subs="-callouts"]
.deps.edn
----
include::example$component/deps.edn[]
----

== The Path So Far
At the beginning of this guide, we set out to create a Pedestal
component, demonstrate its usage as well as how to test it without
starting the http server. In the process, we also introduced a few general purpose
test helpers.

Keep in mind that Pedestal services are highly configurable. It's
important to separate that configuration from the core component
implementation. By limiting our component's responsibilities to http
server and Pedestal provider life cycle support, we can use it in a
wide variety of Pedestal implementations.

