# Decision Log

Document design and architecture decisions.

A lighter-weight alternative to
https://github.com/joelparkerhenderson/architecture-decision-record[Architecture Decision Record (ADR)].

== Websocket Routes (Feb 2025)

Support for WebSockets has been evolving over time; originally added as Jetty-specific prior to Pedestal 0.6.0, it was made more general in Pedestal 0.7.0; however it has always operated outside of
routing, which has proven even more problematic than for resources.

These prior attempts were based around `ServerContainer.addEndpoint()`, which establishes
an addressable WebSocket endpoint, as-if it had been specified in a WAR's web.xml.

WebSockets are specified by https://www.rfc-editor.org/info/rfc6455[RFC 6455] and
https://jcp.org/aboutJava/communityprocess/final/jsr356/index.html[JSR-000356  Java API for WebSocket],

Jetty 12: Java 17, Jakarta EE8 - EE10.

Java API is clearly oriented towards Java-code w/ annotations, things we have to fight against in Clojure-land.

Ping/Pong - check that connection is still alive.  Receive a ping, respond to that peer with a pong.

Explicit references to path params, that map perfectly to Pedestal.

Lot of notes about path conflicts which we'll avoid with Sawtooth.

6.4 - Programmatic Server Deployment

ServerContainer.addEndpoint(), called from a ServletContextListener.
Is it possible they knew web.xml was running out of steam?

No mention of ServerContainer.upgradeHttpToWebSocket().

Maybe extend table routes to allow extra key/value pairs in the routes.

Ah. https://jakarta.ee/specifications/websocket/2.1/jakarta-websocket-spec-2.1.pdf[Jakarta EE - WebSocket 2.1 Specification] (PDF).

https://github.com/jakartaee/websocket/issues/211[jakartaee issue 211] discusses need for `upgradeHttpToWebSocket`.
- Pedestal is the "front controller / front servlet"

Inside `upgradeHttpToWebSocket`, a response is sent to the client; will need a Pedestal mechanism to support
this case, where we unwind the interceptor chain w/o a :response being present. Maybe add an empty response map
to signal that response was provided out-of-band?

Negotiation (of protocol, etc.) via a stack of interceptors?  How to wrap modifyHandshake()?

```
        public static final String JAKARTA_WEBSOCKET_CONTAINER_ATTRIBUTE = jakarta.websocket.server.ServerContainer.class.getName();

        // Store a reference to the ServerContainer per - jakarta.websocket spec 1.0 final - section 6.4: Programmatic Server Deployment
        servletContext.setAttribute(JAKARTA_WEBSOCKET_CONTAINER_ATTRIBUTE, container);
```

    (-> request :servlet-request .getServletContext (.getAttribute "jakarta.websocket.server.ServerContainer"))


Must have a ServerEndpointConfig, it must be built with a non-nil class (i.e., `FnEndpoint`).

Class must extend Endpoint, or have one of a couple of annotations. We have the former.

Class must be public. Ok.

Sub-class or reified impl of ServerEndpointConfig$Configurator, to provide modifyHandshake()? I'd favor a shell class
like `FnEndpoint` that delegates to a Clojure function.

Likewise, getEndpointInstance(), which can be built around the shell class.


Is the classpath for the server module not quite right w.r.t. websocket-api dependency?


== Testing Revamp (Jan 2025)

In earlier versions of Pedestal, the `io.pedestal.test` namespace directly contained `reify`-ed mock
implementations of the relevant Servlet API types: `HttpServletRequest`, `HttpServletResponse`, and so forth.

To some degree, these were abuses of reified types, because almost none of the mocks fully implemented all the
necessary methods footnote:[Clojure allows you to only partially implement an interface in a nominally concrete type.]; further, because of limitations to reified types, they did not always inherit common
behavior from base classes provided by the Servlet API.

By converting these to full Java mock implementations, it is more clear that the mocks match the Servlet API,
as failure to do so result in a compilation error. It also makes it clear what is, and is not, implemented
on a method-by-method basis. In addition, the Servlet API is, by design, filled with mutable state - managing
that mutable state inside a Java class is far simpler than doing so in Clojure code.

We feel that the end result is more complete and maintainable, at the cost of adding several large (and mostly
empty) Java classes to the build.

Using this approach, the `FnServlet` was also converted from reified type to a Java class; this class
is provided by tfhe api:servlet[ns=io.pedestal.http.servlet] function, and in an embedded Pedestal application,
represents the initial bridge from the Java Servlet API to the Clojure and Pedestal implementations.

== Resource Routes (Jan 2025)

Routing is a central concept in Pedestal, and so it causes friction when other important concepts
are inconsistent with it.  One common example is how Pedestal makes file system or class path resources
available; this happens outside of routing - by default, it occurs just before the router interceptor
in the default interceprtor stack.

Having resources operating outside of routing means that there can be conflicts between resources and routes that go undiagnosed.  It also means that it is not possible to
reverse the URI for a resource in the way that is possible for endpoints defined in the routing table.

In addition, exposing resources as routes has opened up new paths for caching, leading to greater
efficiency when serving such resources.

Whether support for the interceptor-based approach for resources remains fully supported, or is
deprecated, is an outstanding question.

- The route-based resources are demonstrably faster than interceptor-based.

== Jetty 12 (Dec 2024)

Although Pedestal 0.7 bumped the supported version of Jetty from 9 to Jetty 11, this was
only an interrum solution - Jetty 9 ended community support in June 2022, with EOL slated for Feb 2025,
but Jetty 11 ended community support in Jan 2024, and EOL in Jan 2025.

Thus, there is no reason to continue supporting both Jetty 11 and Jetty 12; Jetty 12 does
not yet have a scheduled EOL.

So, although initial plans were to support both 11 and 12 in Pedestal 0.8, we have pivoted to
only supporting Jetty 12.

== Routing Fragments (Fall 2024)

The original intention of the _routing table_ was that an application would construct a single
routing specification at startup; this would be converted to a routing table and combined with a router to
form a routing interceptor.

This is sufficient for many small projects using Pedestal; for larger users, such as the vast number of services deployed at Nubank, it has proven insufficient.

Nubank services are built on common libraries; both the application and library layers each contribute
portions of the routing table; this is a haphazard process in Pedestal 0.7 and earlier, because
certain APIs assume just a single routing specification for the entire application.


In Pedestal 0.8, this was
xref:reference:routing-changes.adoc[reworked]
(sacrificing some backwards compatibility) to allow
for routing fragments, that can be properly combined, verified for correctness, and utilized
by the framework.

== Sawtooth Router (Sep 2024)

A common query internally at Nubank, when asked "How can we make things better?" was a call for help with
routes, particularily identifying routing conflicts.

The existing router implementation, the
xref:reference:prefix-tree-router.adoc[]
had specific rules for dealing with any conflicts, but did a bad job of emitting warnings
about such conflicts.

xref:reference:sawtooth-router.adoc[Sawtooth]
was created to address these concerns; it's behavior when conflicts occur is not defined, but
it was designed to do a good job of identifying routing conflicts.

Although the original goal was to create a router that was as fast, or faster, than
prefix tree, that turned out to be difficult to achieve footnote:[There was a long series of
attempted optimizations to address this, which bore very limited fruit.];
Sawtooth is nearly as fast as Prefix Tree, with a difference in micro-seconds per routing execution.

The final decision was whether to make sawtooth the _default_ router; this seemed acceptible
give its reasonable performance, and improved ergonomics.  The other routers, prefix tree included,
continue to exist for backwards compatibility reasons, and to support cases where Sawtooth
is not the best fit.





